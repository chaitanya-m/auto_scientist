# run_experiment.py

import os
import numpy as np
import pandas as pd
import tensorflow as tf
from keras import layers, models

from data_gen.problems import AutoencoderProblem, Problem
from envs import FunctionGraphEnv

def build_uniform_policy(obs_dim: int, action_dim: int) -> models.Model:
    """
    Returns a Keras model that maps any observation to uniform probabilities.
    """
    inp = layers.Input(shape=(obs_dim,))
    out = layers.Dense(
        action_dim,
        activation="softmax",
        kernel_initializer=tf.constant_initializer(1.0/action_dim),
        bias_initializer=tf.constant_initializer(0.0)
    )(inp)
    model = models.Model(inp, out)
    model.compile(optimizer="adam", loss="categorical_crossentropy")
    return model

def run_simple_experiment(
    problem: Problem,
    problem_seed: int = 0,
    mcts_budget: int = 10,
    steps: int = 20,
) -> (pd.DataFrame, dict):
    """
    Runs a single MCTS experiment on one Problem instance,
    returning a DataFrame of per-step metrics and a summary dict.
    """
    # 1) Environment and agent setup
    env = FunctionGraphEnv(problem=problem, seed=problem_seed)
    obs, _ = env.reset()
    obs_dim = obs.shape[0]
    action_dim = env.action_space.n

    policy_model = build_uniform_policy(obs_dim, action_dim)
    from agents.mcts import SimpleMCTSAgent
    agent = SimpleMCTSAgent(env=env, policy_model=policy_model,
                             search_budget=mcts_budget, c=1.0)

    # 2) Run the search loop
    metrics = []
    reuse_count = 0

    for step in range(steps):
        prev_best = env.best_mse
        action = agent.mcts_search()
        obs, reward, done, truncated, info = env.step(action)

        did_reuse = (action == 2)
        if did_reuse:
            reuse_count += 1

        improvement = max(0.0, prev_best - env.current_mse)

        metrics.append({
            "seed": problem_seed,
            "step": step,
            "action": action,
            "did_reuse": did_reuse,
            "cumulative_reuse": reuse_count,
            "mse": env.current_mse,
            "improvement": improvement,
            "nodes": len(env.composer.nodes),
            "repo_size": len(env.repository),
            "improvement_count": env.improvement_count,
            "deletion_count": env.deletion_count,
            "reward": reward
        })

        print(
            f"[Seed {problem_seed} | Step {step:2d}] "
            f"act={action} | reuse={reuse_count} "
            f"| mse={env.current_mse:.4f} "
            f"| nodes={len(env.composer.nodes)} "
            f"| repo={len(env.repository)}"
        )

    df = pd.DataFrame(metrics)

    # 3) Compute summary for this run
    eps = 0.01 * problem.reference_mse
    steps_to_eps = df[df.mse <= problem.reference_mse + eps].step.min()
    summary = {
        "seed": problem_seed,
        "steps_to_epsilon": float(steps_to_eps) if not np.isnan(steps_to_eps) else np.nan,
        "total_reuse": reuse_count,
        "final_mse": float(df.mse.iloc[-1]),
        "final_nodes": int(df.nodes.iloc[-1]),
        "final_repo_size": int(df.repo_size.iloc[-1])
    }

    return df, summary

def main(problem_cls, phase: int = 0, mcts_budget: int = 8, steps: int = 15, output_dir: str = "results"):
    """
    Runs experiments for all problems generated by the given Problem class.
    
    phase       : Integer phase (0 = basic, 1 = intermediate, >1 extrapolated).
    """
    os.makedirs(output_dir, exist_ok=True)

    from experiment_runner import run_experiments
    run_experiments(
        problem_cls=problem_cls,
        phase=phase,
        num_problems=2,
        mcts_budget=mcts_budget,
        steps=steps,
        output_dir=output_dir
    )

if __name__ == "__main__":
    import sys
    from data_gen import problems as prob_mod

    # If a class name is provided, try to use it as the problem class.
    if len(sys.argv) > 1:
        cls_name = sys.argv[1]
        try:
            problem_cls = getattr(prob_mod, cls_name)
        except AttributeError:
            sys.exit(f"Error: Problem class '{cls_name}' not found in data_gen.problems")
    else:
        from data_gen.problems import AutoencoderProblem as problem_cls

    # Since phases are now integers, default to 0 (basic phase)
    main(problem_cls=problem_cls, phase=0)
